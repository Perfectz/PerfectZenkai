{"version":3,"file":"utils-gVHD05Os.js","sources":["../../node_modules/uuid/dist/esm-browser/stringify.js","../../node_modules/uuid/dist/esm-browser/rng.js","../../node_modules/uuid/dist/esm-browser/native.js","../../node_modules/uuid/dist/esm-browser/v4.js","../../node_modules/react-swipeable/es/index.js"],"sourcesContent":["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import * as React from 'react';\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = React.useRef(Object.assign({}, initialState));\n    const transientProps = React.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = React.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = React.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };\n//# sourceMappingURL=index.js.map\n"],"names":["byteToHex","i","push","toString","slice","getRandomValues","rnds8","Uint8Array","native","randomUUID","crypto","bind","v4","options","buf","offset","rnds","random","_a","rng","Error","length","arr","toLowerCase","unsafeStringify","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","cos","sin","getHandlers","set","handlerProps","onStart","event","isTouch","touches","state","props","document","addEventListener","onMove","onUp","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","timeStamp","x","y","deltaX","deltaY","absX","abs","absY","time","velocity","sqrt","vxvy","dir","getDirection","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","e","removeEventListener","attachTouch","el","cleanup","baseOptions","tls","forEach","h","o","output","ref","addState","cleanUpTouch","onMouseDown","useSwipeable","transientState","React.useRef","transientProps","previousProps","current","defaultKey","handlers","React.useMemo","stateSetter","updateTransientState"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}